using System;
using System.Collections.Generic;
using UnityEditor;
using UnityEngine;
using UnityEngine.Splines;
using Debug = UnityEngine.Debug;

namespace VARLab.TradesElectrical
{
    public class VertexSorter : IComparer<Vector3>
    {
        //Sort the vertices radially around the center, going clockwise from the top. 
        //this can account for many shapes, but not those that are overly complex, or that have repeating layers
        public int Compare(Vector3 x, Vector3 y)
        {
            float angleA = Vector3.SignedAngle(new Vector3(0, -1, 0), x.normalized, Vector3.forward);
            float angleB = Vector3.SignedAngle(new Vector3(0, -1, 0), y.normalized, Vector3.forward);

            if (angleA > angleB)
            {
                return 1;
            }

            if (angleA < angleB)
            {
                return -1;
            }
            else
            {
                return 0;
            }
        }
    }

    /*
    This script allows us to create a tube or wire with a custom defined cross section.
    The existing Spline Extruder that comes in the Unity package only allows for shapes with regularly spaced
    faces, such as triangular prisms, rectangular prisms, and cylinders.

    There are some limitations on what cross sections can be used - mainly that the cross section must have vertices
    that can be ordered clockwise while following an edge.

    This system should be attached to a spline that has a Spline Instantiate script attached and defined.

    Multiple meshes can be applied ot the spline extruder, but they must have an identical vertex count in order to have any semblance of correct behavior
    Your milage may still vary on this.

    It is possible to get some finer control of the objects from the Spline Instantiate are baked down, but this is not required
    */
    [ExecuteInEditMode]
    [RequireComponent(typeof(SplineInstantiate))]
    [RequireComponent(typeof(MeshFilter))]
    [RequireComponent(typeof(MeshRenderer))]
    [RequireComponent(typeof(MeshCollider))]
    public class CustomMeshSplineExtrude : MonoBehaviour
    {
        private const string MeshPath = "Assets/Mesh Assets/";

        private List<Vector3>[] allPoints;
        private List<Vector3>[] allNormals;
        private readonly List<MeshFilter> allMeshes = new();

        public void RegenerateMesh()
        {
            ClearMesh();

            Mesh generatedMesh = new Mesh
            {
                name = "poly_" + name
            };
            string meshName = "poly_" + name;
            GetComponent<MeshFilter>().sharedMesh = generatedMesh;
            GetComponent<MeshCollider>().sharedMesh = generatedMesh;
#if UNITY_EDITOR
            AssetDatabase.CreateAsset(GetComponent<MeshFilter>().sharedMesh, MeshPath + meshName + ".asset");
#endif

            GatherMeshes();
            FaceWinder();
        }

        public void ClearMesh()
        {
            if (TryGetComponent(out MeshFilter meshFilter) && meshFilter.sharedMesh)
            {
                meshFilter.sharedMesh.Clear();

                if (allPoints != null)
                {
                    Array.Clear(allPoints, 0, allPoints.Length);
                }

                if (allNormals != null)
                {
                    Array.Clear(allNormals, 0, allNormals.Length);
                }

                allMeshes.Clear();
            }
        }

        private void GatherMeshes()
        {
            // Collect all children of this object. Objects see themselves as children when grabbed  this way.
            // Meshes generated by SplineInstantiate are hidden in the Hierachy and they are children of this transform.
            var childInstances = transform.GetComponentsInChildren<Transform>();
            foreach (Transform child in childInstances)
            {
                if (!child.CompareTag("CustomMeshShape"))
                {
                    continue;
                }

                //discard this object's self, as well as any children without mesh filters
                if (child != gameObject.transform && child.gameObject.TryGetComponent(out MeshFilter meshFilter))
                {
                    allMeshes.Add(meshFilter);
                }
            }

            allPoints = new List<Vector3>[allMeshes.Count];
            allNormals = new List<Vector3>[allMeshes.Count];

            for (int i = 0; i < allMeshes.Count; i++)
            {
                SortPoints(i, allMeshes[i].sharedMesh);
            }
        }

        private void SortPoints(int loop, Mesh ringMeshInstance)
        {
            // Sorted list to keep track of normal indexes after sorting vertices radially around the center
            SortedList<Vector3, int> sortedVertices = new(ringMeshInstance.vertices.Length, new VertexSorter());
            for (int i = 0; i < ringMeshInstance.vertices.Length; i++)
            {
                sortedVertices.Add(ringMeshInstance.vertices[i], i);
            }

            List<Vector3> ringMeshPoints = new List<Vector3>(sortedVertices.Keys);
            for (int i = 0; i < ringMeshPoints.Count; i++)
            {
                // Move the coordinates from local space to world space
                Vector3 worldVertexPosition = allMeshes[loop].transform.TransformPoint(ringMeshPoints[i]);
                ringMeshPoints[i] = worldVertexPosition - transform.position;
            }

            allPoints[loop] = ringMeshPoints;

            allNormals[loop] = new List<Vector3>(sortedVertices.Count);
            // Map normals to their vertices indexes
            foreach (int sortedNormalIndex in sortedVertices.Values)
            {
                allNormals[loop].Add(ringMeshInstance.normals[sortedNormalIndex]);
            }
        }

        private void FaceWinder()
        {
            int countVerts = allPoints.Length * allPoints[0].Count;
            int currentVert = 0;

            Vector3[] meshVerts = new Vector3[countVerts];
            Vector3[] meshNormals = new Vector3[countVerts];
            int[] meshTris = new int[(countVerts - allPoints[0].Count) * 2 * 3];

            //loop through and place all stored verts so they can be used to begin to draw the shape
            for (int i = 0; i < allPoints.Length; i++)
            {
                for (int j = 0; j < allPoints[i].Count; j++)
                {
                    meshVerts[currentVert] = allPoints[i][j];
                    Vector3 norm = allMeshes[i].transform.TransformVector(allNormals[i][j]);
                    meshNormals[currentVert] = norm;
                    currentVert++;
                }
            }

            Mesh generatedMesh = GetComponent<MeshFilter>().sharedMesh;
            generatedMesh.vertices = meshVerts;
            generatedMesh.normals = meshNormals;

            int triSpot = 0;
            for (int i = 0; i < generatedMesh.vertices.Length - allPoints[0].Count; i++)
            {
                if ((i + 1) % allPoints[0].Count == 0)
                {
                    meshTris[triSpot] = i;
                    triSpot++;
                    meshTris[triSpot] = i - allPoints[0].Count + 1;
                    triSpot++;
                    meshTris[triSpot] = i + 1;
                    triSpot++;

                    meshTris[triSpot] = i;
                    triSpot++;
                    meshTris[triSpot] = i + 1;
                    triSpot++;
                    meshTris[triSpot] = i + allPoints[0].Count;
                    triSpot++;
                }
                else
                {
                    meshTris[triSpot] = i;
                    triSpot++;
                    meshTris[triSpot] = i + allPoints[0].Count + 1;
                    triSpot++;
                    meshTris[triSpot] = i + allPoints[0].Count;
                    triSpot++;

                    meshTris[triSpot] = i;
                    triSpot++;
                    meshTris[triSpot] = i + 1;
                    triSpot++;
                    meshTris[triSpot] = i + allPoints[0].Count + 1;
                    triSpot++;
                }
            }

            generatedMesh.triangles = meshTris;

            Debug.Log("Vertex Count per mesh is: " + allPoints[0].Count);
            Debug.Log("The total number of triangles: " + meshTris.Length);
        }
    }
}
